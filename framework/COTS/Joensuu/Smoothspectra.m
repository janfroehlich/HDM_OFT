function Smoothspectra
%
% Smoothspectra for Matlab
% Version 1.0, October 15 2012
% Copyright (c) Hannu Laamanen, Mika Flinkman.
%
% This program is used for generating a set of 716784 smooth reflectance 
% spectra. This data set is saved in a Matlab file "ndata.mat" in the
% current working folder. The program does not require any input parameter 
% or additional argument.
%
% This program can be copied, used and modified without restrictions. 
% Please report any problem to mika.flinkman@uef.fi
%
% Main reference:
% Title: Number of colors generated by non-fluorescent reflectance spectra
% Authors: Mika Flinkman, Hannu Laamanen, Pasi Vahimaa, Markku Hauta-Kasari
% Journal: Journal of Optical Society of America A (in press)
% volume = x, number = x, pages = x, year = x
% 
%===============================================================
%
%Restrictions for smoothness:
s(1)=-.0094;
s(2)=0.0244;
s(3)=-.0018;
s(4)=0.0015074384143825;

%value k acts as the index number of spectra through the program.
%
data=zeros(401,716784);
k=0;
%   Formation of type A spectra.
%
% The spectra are formed by giving height parameter (varies between 0.01
% and 5) and the smoothness constraints. After the spectrum is formed with 
% given values, it is added after 401 values of zeroes. Using the formed 
% spectrum as a base, variations are generated by moving the last value of 
% spectrum to the beginning and saving it as the next spectrum. This is 
% repeted until all variations are generated. After this the height
% parameter is increased by one step and the process is repated again.
%
for n=1:500
    t=spectrumA(n/100,s(1),s(2),s(3),s(4));
    for m=1:length(t)
        k=k+1;
        t=t([end,1:end-1],1);
        data(:,k)=t(1:401,1);
    end
    clc, disp(['Natural spectra generation: ' num2str(n/10) '%'])  
end
%
%   Formation of type B spectra.
%
for n=1:500
    t=spectrumB(n/100,s(1),s(2),s(3),s(4));
    for m=1:length(t)
        k=k+1;
        t=t([end,1:end-1],1);
        data(:,k)=t(1:401,1);
    end
    clc, disp(['Natural spectra generation: ' num2str((500+n)/10) '%'])
end
%
%Smooth reflectance data is saved in a MATLAB-file "ndata.mat".
%
save ndata.mat data -v7.3

%===============================================================

function out=spectrumA(h,d1min,d1max,d2min,d2max)

%This subprogram forms type A spectra 

% Forming the first derivatives for different "quarters" of spectra.

%%%1st quarter
n1=d1max/d2max;
m1=[(n1-floor(n1))*d2max;d2max*ones(floor(n1),1)];
s1=[];
for o1=1:length(m1)
        s1(o1,1)=sum(m1(1:o1,1));
end

%%%2nd quarter
n2=abs(d1max/d2min);
if n2==floor(n2),
    m2=d2min*ones(floor(n2),1);
else
    m2=[d2min*ones(floor(n2),1);(n2-floor(n2))*d2min];
end
s2=[];
for o2=1:length(m2)
        s2(o2,1)=d1max+sum(m2(1:o2,1));
end

%%%3rd quarter
n3=abs(d1min/d2min);
m3=[(n3-floor(n3))*d2min;d2min*ones(floor(n3),1)];
s3=[];
for o3=1:length(m3)
        s3(o3,1)=sum(m3(1:o3,1));
end
s3=s3(2:end,1);

%%%4th quarter
n4=abs(d1min/d2max);
m4=[d2max*ones(floor(n4),1);(n4-floor(n4))*d2max];
s4=[];
for o4=1:length(m4)
        s4(o4,1)=d1min+sum(m4(1:o4,1));
end
s4=s4(1:end-1,1);

% Calculation of height he required by two first quarters.
% If he > 1, ERROR is printed. Check the values of derivatives d1min,
% d1max, d2min and d2max

s=[0;s1;s2];
e=[];
for p=1:length(s)
    e(p,1)=sum(s(1:p),1);
end

he1=max(e);
if he1>1,
    fprintf('ERROR');
end

% Calculation of height he2 required by two last quarters.
% If he2 > 1, ERROR is printed. Check the values of derivatives d1min,
% d1max, d2min and d2max

s=[0;s3;s4];
e=[];
for p=1:length(s)
    e(p,1)=sum(s(1:p),1);
end

he2=abs(min(e));
if he2>1,
    fprintf('ERROR');
end

he=max([he1,he2]);

% Formation of values for the 1st derivative

if h > he && h <= 1,
    n=round((h-he1)/d1max);
    n2=round((h-he2)/abs(d1min));
    z=[0;s1;d1max*ones(n,1);s2;s3;d1min*ones(n2,1);s4];
elseif h > 1,
    n=round((1-he1)/d1max);
    n2=round((1-he2)/abs(d1min));
    m=ceil(100*(h-1));
    z=[0;s1;d1max*ones(n,1);s2;zeros(m,1);s3;d1min*ones(n2,1);s4];
else % if h < he
    if h < he1 && h < he2,
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s1));
            ru=round(x(f)*length(s2));
            s=[0;s1(1:rl,1);s2(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(e);
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s1));s1=s1(1:rl,1);
        ru=round(x*length(s2));s2=s2(end-ru+1:end,1);
        s=[0;s1;s2];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu1=max(e);
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s3));
            ru=round(x(f)*length(s4));
            s=[0;s3(1:rl,1);s4(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(abs(e));
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s3));s3=s3(1:rl,1);
        ru=round(x*length(s4));s4=s4(end-ru+1:end,1);
        s=[0;s3;s4];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu2=max(abs(e));
        z=[0;s1;h-hu1;s2;s3;hu2-h;s4];
    elseif h < he1 && h > he2,
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s1));
            ru=round(x(f)*length(s2));
            s=[0;s1(1:rl,1);s2(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(e);
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s1));s1=s1(1:rl,1);
        ru=round(x*length(s2));s2=s2(end-ru+1:end,1);
        s=[0;s1;s2];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu=max(e);
        n2=round((h-he2)/abs(d1min));
        z=[0;s1;h-hu;s2;s3;d1min*ones(n2,1);s4];
    elseif h > he1 && h < he2,
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s3));
            ru=round(x(f)*length(s4));
            s=[0;s3(1:rl,1);s4(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(abs(e));
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s3));s3=s3(1:rl,1);
        ru=round(x*length(s4));s4=s4(end-ru+1:end,1);
        s=[0;s3;s4];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu=max(abs(e));
        n=round((h-he1)/d1max);
        z=[0;s1;d1max*ones(n,1);s2;s3;hu-h;s4];
    end
end

% Defining specrum using the 1st derivative

out=[];
for p=1:length(z)
    out(p,1)=sum(z(1:p),1);
end
out=[zeros(401,1);out];
out(out>1)=1;
out(out<0)=0;

%===============================================================

function out=spectrumB(h,d1min,d1max,d2min,d2max)

%This subprogram forms type B spectra

% Changing the first derivative values

AA=d1min;
BB=d1max;
d1min=-BB;
d1max=-AA;

% Changing the second derivative values

AA=d2min;
BB=d2max;
d2min=-BB;
d2max=-AA;

% Forming the first derivatives for different "quarters" of spectra.

%%%1st quarter
n1=d1max/d2max;
m1=[(n1-floor(n1))*d2max;d2max*ones(floor(n1),1)];
s1=[];
for o1=1:length(m1)
        s1(o1,1)=sum(m1(1:o1,1));
end

%%%2nd quarter
n2=abs(d1max/d2min);
if n2==floor(n2),
    m2=d2min*ones(floor(n2),1);
else
    m2=[d2min*ones(floor(n2),1);(n2-floor(n2))*d2min];
end
s2=[];
for o2=1:length(m2)
        s2(o2,1)=d1max+sum(m2(1:o2,1));
end

%%%3rd quarter
n3=abs(d1min/d2min);
m3=[(n3-floor(n3))*d2min;d2min*ones(floor(n3),1)];
s3=[];
for o3=1:length(m3)
        s3(o3,1)=sum(m3(1:o3,1));
end
s3=s3(2:end,1);

%%%4th quarter
n4=abs(d1min/d2max);
m4=[d2max*ones(floor(n4),1);(n4-floor(n4))*d2max];
s4=[];
for o4=1:length(m4)
        s4(o4,1)=d1min+sum(m4(1:o4,1));
end
s4=s4(1:end-1,1);

% Calculation of height he required by two first quarters.
% If he > 1, ERROR is printed. Check the values of derivatives d1min,
% d1max, d2min and d2max

s=[0;s1;s2];
e=[];
for p=1:length(s)
    e(p,1)=sum(s(1:p),1);
end

he1=max(e);
if he1>1,
    fprintf('ERROR');
end

% Calculation of height he2 required by two last quarters.
% If he2 > 1, ERROR is printed. Check the values of derivatives d1min,
% d1max, d2min and d2max

s=[0;s3;s4];
e=[];
for p=1:length(s)
    e(p,1)=sum(s(1:p),1);
end

he2=abs(min(e));
if he2>1,
    fprintf('ERROR');
end

he=max([he1,he2]);

% Formation of values for the 1st derivative

if h > he && h <= 1,
    n=round((h-he1)/d1max);
    n2=round((h-he2)/abs(d1min));
    z=[0;s1;d1max*ones(n,1);s2;s3;d1min*ones(n2,1);s4];
elseif h > 1,
    n=round((1-he1)/d1max);
    n2=round((1-he2)/abs(d1min));
    m=ceil(100*(h-1));
    z=[0;s1;d1max*ones(n,1);s2;zeros(m,1);s3;d1min*ones(n2,1);s4];
else % if h < he
    if h < he1 && h < he2,
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s1));
            ru=round(x(f)*length(s2));
            s=[0;s1(1:rl,1);s2(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(e);
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s1));s1=s1(1:rl,1);
        ru=round(x*length(s2));s2=s2(end-ru+1:end,1);
        s=[0;s1;s2];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu1=max(e);
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s3));
            ru=round(x(f)*length(s4));
            s=[0;s3(1:rl,1);s4(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(abs(e));
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s3));s3=s3(1:rl,1);
        ru=round(x*length(s4));s4=s4(end-ru+1:end,1);
        s=[0;s3;s4];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu2=max(abs(e));
        z=[0;s1;h-hu1;s2;s3;hu2-h;s4];
    elseif h < he1 && h > he2,
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s1));
            ru=round(x(f)*length(s2));
            s=[0;s1(1:rl,1);s2(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(e);
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s1));s1=s1(1:rl,1);
        ru=round(x*length(s2));s2=s2(end-ru+1:end,1);
        s=[0;s1;s2];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu=max(e);
        n2=round((h-he2)/abs(d1min));
        z=[0;s1;h-hu;s2;s3;d1min*ones(n2,1);s4];
    elseif h > he1 && h < he2,
        x=0:.001:1;
        h1=[];
        for f=1:1001
            rl=round(x(f)*length(s3));
            ru=round(x(f)*length(s4));
            s=[0;s3(1:rl,1);s4(end-ru+1:end,1)];
            e=[];
            for p=1:length(s)
                e(p,1)=sum(s(1:p),1);
            end
            h1(f,1)=max(abs(e));
        end
        d=find(h1<h);d=max(d);x=x(d);
        rl=round(x*length(s3));s3=s3(1:rl,1);
        ru=round(x*length(s4));s4=s4(end-ru+1:end,1);
        s=[0;s3;s4];
        e=[];
        for p=1:length(s)
            e(p,1)=sum(s(1:p),1);
        end
        hu=max(abs(e));
        n=round((h-he1)/d1max);
        z=[0;s1;d1max*ones(n,1);s2;s3;hu-h;s4];
    end
end

% Defining specrum using the 1st derivative

out=[];
for p=1:length(z)
    out(p,1)=sum(z(1:p),1);
end
out=1-fliplr(out);
out=[ones(401,1);out];
out(out>1)=1;
out(out<0)=0;